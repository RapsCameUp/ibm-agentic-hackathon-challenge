import { Injectable, Logger } from '@nestjs/common';
import { readFileSync } from 'fs';
import { join } from 'path';
import jwt, { SignOptions } from 'jsonwebtoken';
import fetch from 'cross-fetch';

interface WatsonxConfig {
  apiUrl: string;
  agentId: string;
  model: string;
  tenantId?: string;
  deploymentId?: string;
  privateKeyPath?: string;
  jwtAudience?: string;
  jwtIssuer?: string;
  jwtSubject?: string;
  jwtExpiresIn?: number;
}

type WatsonxContentItem = string | { text?: string } | Record<string, unknown>;

interface WatsonxCompletionMessage {
  content?: WatsonxContentItem | WatsonxContentItem[];
  text?: string;
}

interface WatsonxCompletionChoice {
  message?: WatsonxCompletionMessage;
  content?: WatsonxContentItem | WatsonxContentItem[];
  text?: string;
}

interface WatsonxCompletionResponse {
  choices?: WatsonxCompletionChoice[];
}

@Injectable()
export class WatsonxService {
  private readonly logger = new Logger(WatsonxService.name);
  private privateKeyCache?: string;

  isEnabled(): boolean {
    return Boolean(process.env.WATSONX_API_URL && process.env.WATSONX_AGENT_ID);
  }

  async generateReply(message: string): Promise<string> {
    const config = this.resolveConfig();
    if (!config) {
      throw new Error('WatsonX configuration is missing.');
    }

    const token = this.createSignedJwt(message, config);
    const response = await this.invokeWatsonx(message, token, config);

    const reply =
      response?.choices?.[0]?.message?.content ??
      response?.choices?.[0]?.message?.text ??
      response?.choices?.[0]?.content ??
      null;

    if (!reply) {
      this.logger.warn('WatsonX response does not contain a reply payload.', response);
      return 'No response generated by WatsonX.';
    }

    if (typeof reply === 'string') {
      return reply;
    }

    if (Array.isArray(reply)) {
      return reply
        .map((item) => {
          if (typeof item === 'string') {
            return item;
          }
          if (item && typeof item === 'object' && 'text' in item) {
            return String(item.text);
          }
          return '';
        })
        .join(' ')
        .trim();
    }

    return String(reply);
  }

  private resolveConfig(): WatsonxConfig | null {
    const apiUrl = process.env.WATSONX_API_URL?.trim();
    const agentId = process.env.WATSONX_AGENT_ID?.trim();

    if (!apiUrl || !agentId) {
      this.logger.warn('WATSONX_API_URL or WATSONX_AGENT_ID environment variables are not set.');
      return null;
    }

    let jwtExpiresIn: number | undefined;
    const expiresInRaw = process.env.WATSONX_JWT_EXPIRES_IN?.trim();
    if (expiresInRaw) {
      const numeric = Number(expiresInRaw);
      if (!Number.isNaN(numeric) && numeric > 0) {
        jwtExpiresIn = numeric;
      } else {
        this.logger.warn(
          `WATSONX_JWT_EXPIRES_IN value "${expiresInRaw}" is not a positive number. Falling back to default.`,
        );
      }
    }

    return {
      apiUrl: apiUrl.replace(/\/$/, ''),
      agentId,
      model: process.env.WATSONX_MODEL?.trim() || 'wxo-default',
      tenantId: process.env.WATSONX_TENANT_ID?.trim(),
      deploymentId: process.env.WATSONX_AGENT_DEPLOYMENT_ID?.trim(),
      privateKeyPath: process.env.WATSONX_PRIVATE_KEY_PATH?.trim(),
      jwtAudience: process.env.WATSONX_JWT_AUD?.trim(),
      jwtIssuer: process.env.WATSONX_JWT_ISS?.trim(),
      jwtSubject: process.env.WATSONX_JWT_SUB?.trim(),
      jwtExpiresIn,
    };
  }

  private createSignedJwt(message: string, config: WatsonxConfig): string {
    const payload: Record<string, unknown> = {
      user_payload: {
        user_message: message,
      },
    };

    if (config.jwtIssuer) {
      payload.iss = config.jwtIssuer;
    }
    if (config.jwtSubject) {
      payload.sub = config.jwtSubject;
    }
    if (config.jwtAudience) {
      payload.aud = config.jwtAudience;
    }

    const extraPayload = process.env.WATSONX_JWT_EXTRA_PAYLOAD;
    if (extraPayload) {
      try {
        const parsed = JSON.parse(extraPayload);
        Object.assign(payload, parsed);
      } catch (error) {
        this.logger.warn('Unable to parse WATSONX_JWT_EXTRA_PAYLOAD as JSON.', error as Error);
      }
    }

    const privateKey = this.resolvePrivateKey(config);
    const expiresIn = config.jwtExpiresIn ?? 300;
    const signOptions: SignOptions = {
      algorithm: 'RS256',
      expiresIn,
    };

    return jwt.sign(payload, privateKey, signOptions);
  }

  private resolvePrivateKey(config: WatsonxConfig): string {
    if (this.privateKeyCache) {
      return this.privateKeyCache;
    }

    const inlineKey = process.env.WATSONX_PRIVATE_KEY;
    if (inlineKey) {
      this.privateKeyCache = inlineKey.replace(/\\n/g, '\n');
      return this.privateKeyCache;
    }

    const keyPath =
      config.privateKeyPath || join(process.cwd(), 'app', 'wxo_keys', 'client_private_key.pem');

    try {
      this.privateKeyCache = readFileSync(keyPath, 'utf8');
      return this.privateKeyCache;
    } catch (error) {
      this.logger.error(`Unable to read WatsonX private key from path: ${keyPath}`, error as Error);
      throw error;
    }
  }

  private async invokeWatsonx(
    message: string,
    token: string,
    config: WatsonxConfig,
  ): Promise<WatsonxCompletionResponse> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    };

    if (config.tenantId) {
      headers['x-ibm-tenant-id'] = config.tenantId;
    }

    const body: Record<string, unknown> = {
      model: config.model,
      messages: [
        {
          role: 'user',
          content: message,
        },
      ],
    };

    if (config.deploymentId) {
      body.deployment_id = config.deploymentId;
    }

    const response = await fetch(`${config.apiUrl}/v1/agents/${config.agentId}/completions`, {
      method: 'POST',
      headers,
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorText = await response.text();
      this.logger.error(
        `WatsonX API error: ${response.status} ${response.statusText} - ${errorText}`,
      );
      throw new Error(`WatsonX API error: ${response.status}`);
    }

    return response.json() as Promise<WatsonxCompletionResponse>;
  }
}
